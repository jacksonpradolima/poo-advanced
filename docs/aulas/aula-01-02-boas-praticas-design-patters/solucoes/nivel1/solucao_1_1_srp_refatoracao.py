#!/usr/bin/env python3
"""
Solu√ß√£o do Exerc√≠cio 1.1: Refatora√ß√£o SRP - Sistema de Usu√°rio

OBJETIVO: Demonstrar a aplica√ß√£o do Single Responsibility Principle (SRP)
refatorando uma classe que viola este princ√≠pio.

CONCEITOS DEMONSTRADOS:
- Single Responsibility Principle (SRP)
- Dependency Injection
- Separation of Concerns
- Type Hints
- Protocol-based interfaces

AUTOR: Prof. Jackson Antonio do Prado Lima
DATA: 2024-12-19
"""

from typing import Protocol
from datetime import datetime
from abc import ABC, abstractmethod


# =============================================================================
# PROBLEMA ORIGINAL - C√ìDIGO QUE VIOLA SRP
# =============================================================================

class Usuario_Problem√°tico:
    """
    ‚ùå PROBLEMA: Esta classe viola o SRP ao ter m√∫ltiplas responsabilidades:
    1. Gerenciar dados do usu√°rio
    2. Autenticar usu√°rios  
    3. Enviar emails
    4. Fazer logging
    5. Validar emails
    6. Criptografar senhas
    
    Consequ√™ncias:
    - Dif√≠cil de testar (muitas depend√™ncias)
    - Dif√≠cil de manter (mudan√ßas em uma √°rea afetam outras)
    - Viola√ß√£o do princ√≠pio de responsabilidade √∫nica
    - Alto acoplamento
    """
    
    def __init__(self, nome, email, senha):
        self.nome = nome
        self.email = email
        self.senha = senha
        self.logado = False
    
    def fazer_login(self, email, senha):
        if self.email == email and self.senha == senha:
            self.logado = True
            self.enviar_email_boas_vindas()
            self.salvar_log_login()
            return True
        return False
    
    def enviar_email_boas_vindas(self):
        print(f"Enviando email de boas-vindas para {self.email}")
    
    def salvar_log_login(self):
        print(f"Salvando log: {self.nome} fez login em {self._obter_timestamp()}")
    
    def _obter_timestamp(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def validar_email(self, email):
        return "@" in email and "." in email.split("@")[1]
    
    def criptografar_senha(self, senha):
        return f"cripto_{senha}"


# =============================================================================
# SOLU√á√ÉO REFATORADA - APLICANDO SRP
# =============================================================================

# 1. INTERFACES (usando Protocol para maior flexibilidade)
# -----------------------------------------------------------------------------

class ValidadorEmail(Protocol):
    """Interface para valida√ß√£o de email (ISP)"""
    
    def validar(self, email: str) -> bool:
        """Valida formato do email"""
        ...


class ServicoEmail(Protocol):
    """Interface para servi√ßos de email (ISP)"""
    
    def enviar_boas_vindas(self, destinatario: str, nome: str) -> bool:
        """Envia email de boas-vindas"""
        ...


class LoggerSistema(Protocol):
    """Interface para logging do sistema (ISP)"""
    
    def registrar_evento(self, evento: str, detalhes: str) -> None:
        """Registra evento no sistema"""
        ...


class CriptografadorSenha(Protocol):
    """Interface para criptografia de senhas (ISP)"""
    
    def criptografar(self, senha: str) -> str:
        """Criptografa senha"""
        ...
    
    def verificar(self, senha: str, hash_senha: str) -> bool:
        """Verifica se senha corresponde ao hash"""
        ...


# 2. IMPLEMENTA√á√ïES CONCRETAS (Cada uma com responsabilidade √∫nica)
# -----------------------------------------------------------------------------

class ValidadorEmailImpl:
    """
    ‚úÖ RESPONSABILIDADE √öNICA: Validar formato de emails
    
    BENEF√çCIOS:
    - F√°cil de testar
    - Pode ser reutilizada
    - F√°cil de modificar regras de valida√ß√£o
    """
    
    def validar(self, email: str) -> bool:
        """
        Valida formato b√°sico do email.
        
        Args:
            email: String com email a ser validado
            
        Returns:
            bool: True se email √© v√°lido, False caso contr√°rio
            
        Examples:
            >>> validador = ValidadorEmailImpl()
            >>> validador.validar("teste@email.com")
            True
            >>> validador.validar("email_invalido")
            False
        """
        if not email or "@" not in email:
            return False
        
        partes = email.split("@")
        if len(partes) != 2:
            return False
            
        local, dominio = partes
        if not local or not dominio:
            return False
            
        return "." in dominio


class ServicoEmailImpl:
    """
    ‚úÖ RESPONSABILIDADE √öNICA: Enviar emails
    
    BENEF√çCIOS:
    - Pode ser substitu√≠da por implementa√ß√£o real (SendGrid, AWS SES)
    - F√°cil de mockar em testes
    - Configura√ß√£o centralizada
    """
    
    def __init__(self, servidor_smtp: str = "localhost"):
        self._servidor_smtp = servidor_smtp
    
    def enviar_boas_vindas(self, destinatario: str, nome: str) -> bool:
        """
        Envia email de boas-vindas para novo usu√°rio.
        
        Args:
            destinatario: Email do destinat√°rio
            nome: Nome do usu√°rio
            
        Returns:
            bool: True se email foi enviado com sucesso
        """
        # Simula√ß√£o de envio de email
        # Em ambiente real, aqui teria integra√ß√£o com provedor de email
        mensagem = f"Bem-vindo(a) {nome}! Seu cadastro foi realizado com sucesso."
        
        print(f"üìß [EMAIL] Para: {destinatario}")
        print(f"üìß [EMAIL] Assunto: Bem-vindo!")
        print(f"üìß [EMAIL] Corpo: {mensagem}")
        print(f"üìß [EMAIL] Servidor: {self._servidor_smtp}")
        
        # Simular sucesso
        return True


class LoggerSistemaImpl:
    """
    ‚úÖ RESPONSABILIDADE √öNICA: Registrar eventos do sistema
    
    BENEF√çCIOS:
    - Centraliza estrat√©gia de logging
    - Pode ser configurado para diferentes n√≠veis
    - F√°cil de integrar com sistemas externos
    """
    
    def __init__(self, arquivo_log: str = "sistema.log"):
        self._arquivo_log = arquivo_log
    
    def registrar_evento(self, evento: str, detalhes: str) -> None:
        """
        Registra evento no sistema de log.
        
        Args:
            evento: Tipo do evento (ex: 'LOGIN', 'ERRO', 'INFO')
            detalhes: Detalhes espec√≠ficos do evento
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        entrada_log = f"[{timestamp}] {evento}: {detalhes}"
        
        # Em ambiente real, escreveria no arquivo
        print(f"üìã [LOG] {entrada_log}")
        
        # Simular escrita no arquivo
        # with open(self._arquivo_log, 'a') as f:
        #     f.write(entrada_log + '\n')


class CriptografadorSenhaImpl:
    """
    ‚úÖ RESPONSABILIDADE √öNICA: Criptografar e verificar senhas
    
    BENEF√çCIOS:
    - Algoritmo de hash centralizado
    - F√°cil de trocar algoritmo (bcrypt, argon2, etc.)
    - Valida√ß√£o de senhas segura
    """
    
    def __init__(self, algoritmo: str = "sha256"):
        self._algoritmo = algoritmo
    
    def criptografar(self, senha: str) -> str:
        """
        Criptografa senha usando algoritmo configurado.
        
        Args:
            senha: Senha em texto plano
            
        Returns:
            str: Hash da senha
        """
        # Simula√ß√£o simples - em produ√ß√£o usaria bcrypt ou similar
        import hashlib
        
        # Adicionar salt para seguran√ßa
        salt = "sistema_seguro_2024"
        senha_com_salt = f"{senha}{salt}"
        
        hash_objeto = hashlib.sha256(senha_com_salt.encode())
        return hash_objeto.hexdigest()
    
    def verificar(self, senha: str, hash_senha: str) -> bool:
        """
        Verifica se senha corresponde ao hash armazenado.
        
        Args:
            senha: Senha em texto plano
            hash_senha: Hash armazenado
            
        Returns:
            bool: True se senha √© v√°lida
        """
        hash_calculado = self.criptografar(senha)
        return hash_calculado == hash_senha


# 3. CLASSE USUARIO REFATORADA (Apenas dados e identidade)
# -----------------------------------------------------------------------------

class Usuario:
    """
    ‚úÖ RESPONSABILIDADE √öNICA: Representar dados de um usu√°rio
    
    BENEF√çCIOS:
    - Classe simples e focada
    - F√°cil de testar
    - Sem depend√™ncias externas
    - Imutabilidade dos dados essenciais
    """
    
    def __init__(self, nome: str, email: str, senha_hash: str):
        """
        Inicializa usu√°rio com dados validados.
        
        Args:
            nome: Nome completo do usu√°rio
            email: Email do usu√°rio (deve ser validado externamente)
            senha_hash: Hash da senha (deve ser criptografada externamente)
        """
        if not nome or not email or not senha_hash:
            raise ValueError("Nome, email e senha s√£o obrigat√≥rios")
        
        self._nome = nome
        self._email = email  
        self._senha_hash = senha_hash
        self._logado = False
        self._data_criacao = datetime.now()
    
    @property
    def nome(self) -> str:
        """Nome do usu√°rio (read-only)"""
        return self._nome
    
    @property  
    def email(self) -> str:
        """Email do usu√°rio (read-only)"""
        return self._email
    
    @property
    def senha_hash(self) -> str:
        """Hash da senha (read-only)"""
        return self._senha_hash
    
    @property
    def logado(self) -> bool:
        """Status de login atual"""
        return self._logado
    
    @property
    def data_criacao(self) -> datetime:
        """Data de cria√ß√£o do usu√°rio"""
        return self._data_criacao
    
    def marcar_como_logado(self) -> None:
        """Marca usu√°rio como logado (uso interno do autenticador)"""
        self._logado = True
    
    def marcar_como_deslogado(self) -> None:
        """Marca usu√°rio como deslogado"""
        self._logado = False
    
    def __str__(self) -> str:
        """Representa√ß√£o string do usu√°rio"""
        status = "Logado" if self._logado else "Deslogado"
        return f"Usuario(nome='{self._nome}', email='{self._email}', status='{status}')"
    
    def __repr__(self) -> str:
        """Representa√ß√£o t√©cnica do usu√°rio"""
        return (f"Usuario(nome='{self._nome}', email='{self._email}', "
                f"criado_em='{self._data_criacao.isoformat()}')")


# 4. AUTENTICADOR (Orquestra o processo de login)
# -----------------------------------------------------------------------------

class AutenticadorUsuario:
    """
    ‚úÖ RESPONSABILIDADE √öNICA: Orquestrar processo de autentica√ß√£o
    
    BENEF√çCIOS:
    - Coordena diferentes servi√ßos
    - Dependency Injection facilita testes
    - L√≥gica de autentica√ß√£o centralizada
    - F√°cil de estender com novos requisitos
    """
    
    def __init__(self, 
                 validador_email: ValidadorEmail,
                 servico_email: ServicoEmail,
                 logger: LoggerSistema,
                 criptografador: CriptografadorSenha):
        """
        Inicializa autenticador com depend√™ncias injetadas.
        
        Args:
            validador_email: Servi√ßo para valida√ß√£o de emails
            servico_email: Servi√ßo para envio de emails  
            logger: Servi√ßo para logging de eventos
            criptografador: Servi√ßo para verifica√ß√£o de senhas
        """
        self._validador_email = validador_email
        self._servico_email = servico_email
        self._logger = logger
        self._criptografador = criptografador
    
    def criar_usuario(self, nome: str, email: str, senha: str) -> Usuario:
        """
        Cria novo usu√°rio com valida√ß√µes.
        
        Args:
            nome: Nome do usu√°rio
            email: Email do usu√°rio
            senha: Senha em texto plano
            
        Returns:
            Usuario: Inst√¢ncia do usu√°rio criado
            
        Raises:
            ValueError: Se dados s√£o inv√°lidos
        """
        # Validar email
        if not self._validador_email.validar(email):
            raise ValueError(f"Email inv√°lido: {email}")
        
        # Criptografar senha
        senha_hash = self._criptografador.criptografar(senha)
        
        # Criar usu√°rio
        usuario = Usuario(nome, email, senha_hash)
        
        # Registrar cria√ß√£o
        self._logger.registrar_evento(
            "USUARIO_CRIADO", 
            f"Usu√°rio criado: {nome} ({email})"
        )
        
        return usuario
    
    def fazer_login(self, usuario: Usuario, email: str, senha: str) -> bool:
        """
        Executa processo de login completo.
        
        Args:
            usuario: Inst√¢ncia do usu√°rio
            email: Email fornecido para login
            senha: Senha em texto plano
            
        Returns:
            bool: True se login foi bem-sucedido
        """
        try:
            # Verificar se email corresponde
            if usuario.email != email:
                self._logger.registrar_evento(
                    "LOGIN_FALHOU", 
                    f"Email incorreto para usu√°rio: {email}"
                )
                return False
            
            # Verificar senha
            if not self._criptografador.verificar(senha, usuario.senha_hash):
                self._logger.registrar_evento(
                    "LOGIN_FALHOU", 
                    f"Senha incorreta para usu√°rio: {email}"
                )
                return False
            
            # Login bem-sucedido
            usuario.marcar_como_logado()
            
            # Enviar email de boas-vindas
            email_enviado = self._servico_email.enviar_boas_vindas(
                usuario.email, 
                usuario.nome
            )
            
            # Registrar login
            detalhes = f"Login bem-sucedido: {usuario.nome} ({usuario.email})"
            if email_enviado:
                detalhes += " - Email de boas-vindas enviado"
            
            self._logger.registrar_evento("LOGIN_SUCESSO", detalhes)
            
            return True
            
        except Exception as e:
            # Log de erro
            self._logger.registrar_evento(
                "LOGIN_ERRO", 
                f"Erro durante login de {email}: {str(e)}"
            )
            return False


# =============================================================================
# EXEMPLO DE USO - DEMONSTRA√á√ÉO DA SOLU√á√ÉO
# =============================================================================

def demonstrar_solucao():
    """
    Demonstra o uso da solu√ß√£o refatorada aplicando SRP.
    
    BENEF√çCIOS EVIDENCIADOS:
    1. Cada classe tem responsabilidade √∫nica
    2. F√°cil de testar (depend√™ncias injetadas)
    3. F√°cil de estender (novos validadores, servi√ßos, etc.)
    4. Baixo acoplamento entre componentes
    """
    
    print("üîß DEMONSTRA√á√ÉO: Sistema de Usu√°rio Refatorado (SRP)")
    print("=" * 60)
    
    # 1. Configurar depend√™ncias (Dependency Injection)
    print("\nüì¶ 1. Configurando depend√™ncias...")
    validador = ValidadorEmailImpl()
    servico_email = ServicoEmailImpl("smtp.empresa.com")
    logger = LoggerSistemaImpl("app.log")
    criptografador = CriptografadorSenhaImpl("sha256")
    
    # 2. Criar autenticador
    print("\nüîê 2. Criando autenticador...")
    autenticador = AutenticadorUsuario(
        validador_email=validador,
        servico_email=servico_email,
        logger=logger,
        criptografador=criptografador
    )
    
    # 3. Criar usu√°rio
    print("\nüë§ 3. Criando usu√°rio...")
    try:
        usuario = autenticador.criar_usuario(
            nome="Jo√£o Silva",
            email="joao@email.com", 
            senha="minhasenha123"
        )
        print(f"‚úÖ Usu√°rio criado: {usuario}")
        
    except ValueError as e:
        print(f"‚ùå Erro na cria√ß√£o: {e}")
        return
    
    # 4. Fazer login com credenciais corretas
    print("\nüîë 4. Fazendo login com credenciais corretas...")
    sucesso = autenticador.fazer_login(
        usuario=usuario,
        email="joao@email.com",
        senha="minhasenha123"
    )
    
    if sucesso:
        print(f"‚úÖ Login bem-sucedido! Status: {usuario}")
    else:
        print("‚ùå Login falhou!")
    
    # 5. Tentar login com credenciais incorretas
    print("\nüö´ 5. Tentando login com senha incorreta...")
    usuario.marcar_como_deslogado()  # Reset para teste
    
    sucesso = autenticador.fazer_login(
        usuario=usuario,
        email="joao@email.com", 
        senha="senha_errada"
    )
    
    if sucesso:
        print("‚ùå ERRO: Login deveria ter falhado!")
    else:
        print("‚úÖ Login falhou corretamente (senha incorreta)")
    
    print("\nüìä 6. An√°lise da Refatora√ß√£o:")
    print("   ‚úÖ SRP: Cada classe tem responsabilidade √∫nica")
    print("   ‚úÖ DIP: Depend√™ncias injetadas via interfaces")
    print("   ‚úÖ ISP: Interfaces espec√≠ficas e coesas")
    print("   ‚úÖ Testabilidade: F√°cil de mockar depend√™ncias")
    print("   ‚úÖ Manutenibilidade: Mudan√ßas isoladas por responsabilidade")


# =============================================================================
# TESTES AUTOMATIZADOS
# =============================================================================

def executar_testes():
    """
    Executa testes b√°sicos para validar a implementa√ß√£o.
    
    NOTA: Em um projeto real, estes estariam em arquivos separados
    usando pytest ou unittest.
    """
    
    print("\nüß™ EXECUTANDO TESTES...")
    print("=" * 40)
    
    # Setup
    validador = ValidadorEmailImpl()
    servico_email = ServicoEmailImpl()
    logger = LoggerSistemaImpl()
    criptografador = CriptografadorSenhaImpl()
    
    autenticador = AutenticadorUsuario(
        validador, servico_email, logger, criptografador
    )
    
    # Teste 1: Valida√ß√£o de email
    print("\nüîç Teste 1: Valida√ß√£o de email...")
    assert validador.validar("teste@email.com") == True
    assert validador.validar("email_invalido") == False
    assert validador.validar("") == False
    print("‚úÖ Valida√ß√£o de email: PASSOU")
    
    # Teste 2: Criptografia de senha
    print("\nüîí Teste 2: Criptografia de senha...")
    senha = "teste123"
    hash_senha = criptografador.criptografar(senha)
    assert criptografador.verificar(senha, hash_senha) == True
    assert criptografador.verificar("senha_errada", hash_senha) == False
    print("‚úÖ Criptografia de senha: PASSOU")
    
    # Teste 3: Cria√ß√£o de usu√°rio
    print("\nüë§ Teste 3: Cria√ß√£o de usu√°rio...")
    usuario = autenticador.criar_usuario("Test User", "test@email.com", "senha123")
    assert usuario.nome == "Test User"
    assert usuario.email == "test@email.com"
    assert not usuario.logado
    print("‚úÖ Cria√ß√£o de usu√°rio: PASSOU")
    
    # Teste 4: Login bem-sucedido
    print("\nüîë Teste 4: Login bem-sucedido...")
    sucesso = autenticador.fazer_login(usuario, "test@email.com", "senha123")
    assert sucesso == True
    assert usuario.logado == True
    print("‚úÖ Login bem-sucedido: PASSOU")
    
    # Teste 5: Login com credenciais incorretas
    print("\nüö´ Teste 5: Login com credenciais incorretas...")
    usuario.marcar_como_deslogado()
    sucesso = autenticador.fazer_login(usuario, "test@email.com", "senha_errada")
    assert sucesso == False
    assert usuario.logado == False
    print("‚úÖ Login com credenciais incorretas: PASSOU")
    
    print("\nüéâ TODOS OS TESTES PASSARAM!")


# =============================================================================
# EXECU√á√ÉO PRINCIPAL
# =============================================================================

if __name__ == "__main__":
    # Demonstrar a solu√ß√£o
    demonstrar_solucao()
    
    # Executar testes
    executar_testes()
    
    print("\n" + "=" * 60)
    print("üìö AN√ÅLISE DA REFATORA√á√ÉO:")
    print()
    print("ANTES (C√≥digo Problem√°tico):")
    print("‚ùå Uma classe com 6+ responsabilidades")
    print("‚ùå Alto acoplamento")
    print("‚ùå Dif√≠cil de testar")
    print("‚ùå Dif√≠cil de manter")
    print()
    print("DEPOIS (C√≥digo Refatorado):")
    print("‚úÖ Cada classe com responsabilidade √∫nica (SRP)")
    print("‚úÖ Depend√™ncias injetadas (DIP)")
    print("‚úÖ Interfaces espec√≠ficas (ISP)")
    print("‚úÖ F√°cil de testar e manter")
    print("‚úÖ Baixo acoplamento")
    print("‚úÖ Extensibilidade sem modifica√ß√£o (OCP)")
    print()
    print("üéØ RESULTADO: C√≥digo mais limpo, test√°vel e manuten√≠vel!")

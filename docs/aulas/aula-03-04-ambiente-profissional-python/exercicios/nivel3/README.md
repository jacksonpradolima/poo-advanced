# ðŸ”´ ExercÃ­cios NÃ­vel 3 - AvanÃ§ado

## ExercÃ­cio 3.1: Sistema de E-commerce Completo ðŸ›’

### Contexto
Desenvolva um sistema de e-commerce completo com carrinho de compras, processamento de pedidos, gestÃ£o de estoque, sistema de pagamentos (simulado) e dashboard administrativo. O sistema deve ser enterprise-grade com todas as prÃ¡ticas de desenvolvimento profissional.

### Objetivos PedagÃ³gicos
- Arquitetura de software complexa
- PadrÃµes de design avanÃ§ados
- IntegraÃ§Ã£o de mÃºltiplos domÃ­nios
- Performance e escalabilidade
- Monitoramento e observabilidade

### Requisitos Funcionais

#### GestÃ£o de Produtos
1. **CatÃ¡logo**: Produtos, categorias, variaÃ§Ãµes (tamanho, cor)
2. **Estoque**: Controle por variaÃ§Ã£o, alertas de baixo estoque
3. **Pricing**: PreÃ§os dinÃ¢micos, promoÃ§Ãµes, cupons de desconto
4. **Imagens**: Upload, redimensionamento, otimizaÃ§Ã£o
5. **SEO**: URLs amigÃ¡veis, metadados, sitemap

#### Sistema de UsuÃ¡rios
1. **AutenticaÃ§Ã£o**: Registro, login, recuperaÃ§Ã£o de senha
2. **Perfis**: Dados pessoais, endereÃ§os mÃºltiplos, preferÃªncias
3. **PermissÃµes**: Cliente, admin, vendedor, suporte
4. **HistÃ³rico**: Pedidos, visualizaÃ§Ãµes, wishlist

#### Carrinho e Checkout
1. **Carrinho**: Persistente, cÃ¡lculo automÃ¡tico, validaÃ§Ãµes
2. **Checkout**: Multi-step, validaÃ§Ã£o de endereÃ§o, fretes
3. **Pagamentos**: MÃºltiplas formas, parcelamento, validaÃ§Ãµes
4. **ConfirmaÃ§Ã£o**: Email, SMS, PDF do pedido

#### GestÃ£o de Pedidos
1. **Workflow**: Pendente â†’ Pago â†’ Preparando â†’ Enviado â†’ Entregue
2. **Tracking**: CÃ³digos de rastreamento, atualizaÃ§Ãµes automÃ¡ticas
3. **DevoluÃ§Ãµes**: Processo automatizado, reembolsos
4. **RelatÃ³rios**: Vendas, produtos mais vendidos, anÃ¡lises

### Arquitetura do Sistema

```
ecommerce-platform/
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ ci.yml
â”‚       â””â”€â”€ cd.yml
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ settings.py
â”‚   â”œâ”€â”€ database.py
â”‚   â””â”€â”€ redis.py
â”œâ”€â”€ ecommerce/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ exceptions.py
â”‚   â”‚   â”œâ”€â”€ middleware.py
â”‚   â”‚   â”œâ”€â”€ decorators.py
â”‚   â”‚   â””â”€â”€ utils.py
â”‚   â”œâ”€â”€ domains/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ produtos/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories.py
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py
â”‚   â”‚   â”œâ”€â”€ usuarios/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.py
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py
â”‚   â”‚   â”œâ”€â”€ carrinho/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py
â”‚   â”‚   â”œâ”€â”€ pedidos/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”œâ”€â”€ workflow.py
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py
â”‚   â”‚   â”œâ”€â”€ pagamentos/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”œâ”€â”€ gateways.py
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py
â”‚   â”‚   â””â”€â”€ estoque/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ models.py
â”‚   â”‚       â”œâ”€â”€ services.py
â”‚   â”‚       â””â”€â”€ schemas.py
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”œâ”€â”€ dependencies.py
â”‚   â”‚   â””â”€â”€ routers/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ produtos.py
â”‚   â”‚       â”œâ”€â”€ usuarios.py
â”‚   â”‚       â”œâ”€â”€ carrinho.py
â”‚   â”‚       â”œâ”€â”€ pedidos.py
â”‚   â”‚       â””â”€â”€ admin.py
â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”‚   â”œâ”€â”€ session.py
â”‚   â”‚   â”‚   â””â”€â”€ migrations/
â”‚   â”‚   â”œâ”€â”€ cache/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ redis_client.py
â”‚   â”‚   â”‚   â””â”€â”€ decorators.py
â”‚   â”‚   â”œâ”€â”€ storage/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ local.py
â”‚   â”‚   â”‚   â””â”€â”€ s3.py
â”‚   â”‚   â””â”€â”€ messaging/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ email.py
â”‚   â”‚       â””â”€â”€ sms.py
â”‚   â””â”€â”€ web/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ static/
â”‚       â”œâ”€â”€ templates/
â”‚       â””â”€â”€ admin/
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py
â”‚   â”œâ”€â”€ fixtures/
â”‚   â”œâ”€â”€ unit/
â”‚   â”‚   â”œâ”€â”€ test_models/
â”‚   â”‚   â”œâ”€â”€ test_services/
â”‚   â”‚   â””â”€â”€ test_utils/
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â”œâ”€â”€ test_api/
â”‚   â”‚   â””â”€â”€ test_workflows/
â”‚   â””â”€â”€ e2e/
â”‚       â”œâ”€â”€ test_user_journey.py
â”‚       â””â”€â”€ test_admin_flows.py
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ seed_data.py
â”‚   â”œâ”€â”€ backup.py
â”‚   â””â”€â”€ deploy.py
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ prometheus.yml
â”‚   â”œâ”€â”€ grafana/
â”‚   â””â”€â”€ alerts/
â””â”€â”€ docs/
    â”œâ”€â”€ api/
    â”œâ”€â”€ architecture/
    â”œâ”€â”€ deployment/
    â””â”€â”€ user_guide/
```

### Modelos de DomÃ­nio Complexos

#### Produto com VariaÃ§Ãµes
```python
# ecommerce/domains/produtos/models.py
from decimal import Decimal
from enum import Enum
from typing import List, Optional, Dict, Any
from uuid import UUID, uuid4
from datetime import datetime

from pydantic import BaseModel, Field, validator
from sqlalchemy import Column, String, Integer, Numeric, Boolean, DateTime, JSON
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import relationship

from ...infrastructure.database.base import Base


class StatusProduto(str, Enum):
    """Status de um produto no catÃ¡logo."""
    ATIVO = "ativo"
    INATIVO = "inativo"
    ESGOTADO = "esgotado"
    DESCONTINUADO = "descontinuado"


class TipoVariacao(str, Enum):
    """Tipos de variaÃ§Ã£o de produto."""
    COR = "cor"
    TAMANHO = "tamanho"
    MATERIAL = "material"
    VOLTAGEM = "voltagem"
    MEMORIA = "memoria"


class Categoria(Base):
    """Categoria de produto com hierarquia."""
    __tablename__ = "categorias"
    
    id = Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid4)
    nome = Column(String(100), nullable=False)
    slug = Column(String(100), unique=True, nullable=False)
    descricao = Column(String(500))
    categoria_pai_id = Column(PG_UUID(as_uuid=True), nullable=True)
    ativo = Column(Boolean, default=True)
    ordem = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relacionamentos
    produtos = relationship("Produto", back_populates="categoria")


class Produto(Base):
    """Produto principal com informaÃ§Ãµes base."""
    __tablename__ = "produtos"
    
    id = Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid4)
    nome = Column(String(200), nullable=False)
    slug = Column(String(200), unique=True, nullable=False)
    descricao_curta = Column(String(300))
    descricao_completa = Column(String(5000))
    sku_base = Column(String(50), unique=True, nullable=False)
    
    # PreÃ§o base (variaÃ§Ãµes podem ter preÃ§os diferentes)
    preco_base = Column(Numeric(10, 2), nullable=False)
    preco_custo = Column(Numeric(10, 2))
    
    # Metadados
    peso = Column(Numeric(8, 3))  # em kg
    dimensoes = Column(JSON)  # {"altura": 10, "largura": 20, "profundidade": 5}
    marca = Column(String(100))
    
    # Status e controle
    status = Column(String(20), default=StatusProduto.ATIVO)
    destaque = Column(Boolean, default=False)
    
    # SEO
    meta_title = Column(String(60))
    meta_description = Column(String(160))
    meta_keywords = Column(String(255))
    
    # Relacionamentos
    categoria_id = Column(PG_UUID(as_uuid=True), nullable=False)
    categoria = relationship("Categoria", back_populates="produtos")
    variacoes = relationship("VariacaoProduto", back_populates="produto")
    imagens = relationship("ImagemProduto", back_populates="produto")
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class VariacaoProduto(Base):
    """VariaÃ§Ã£o especÃ­fica de um produto (ex: Camiseta Azul M)."""
    __tablename__ = "variacoes_produto"
    
    id = Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid4)
    produto_id = Column(PG_UUID(as_uuid=True), nullable=False)
    sku = Column(String(50), unique=True, nullable=False)
    
    # Atributos da variaÃ§Ã£o
    atributos = Column(JSON)  # {"cor": "azul", "tamanho": "M"}
    
    # PreÃ§o especÃ­fico (pode sobrescrever o base)
    preco = Column(Numeric(10, 2))
    preco_promocional = Column(Numeric(10, 2))
    
    # Estoque e disponibilidade
    estoque_atual = Column(Integer, default=0)
    estoque_minimo = Column(Integer, default=5)
    estoque_maximo = Column(Integer, default=1000)
    
    # Status especÃ­fico
    ativo = Column(Boolean, default=True)
    peso_especifico = Column(Numeric(8, 3))
    
    # Relacionamentos
    produto = relationship("Produto", back_populates="variacoes")
    itens_estoque = relationship("MovimentacaoEstoque", back_populates="variacao")
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class ProdutoSchema(BaseModel):
    """Schema Pydantic para validaÃ§Ã£o e serializaÃ§Ã£o."""
    
    id: Optional[UUID] = None
    nome: str = Field(min_length=5, max_length=200)
    descricao_curta: str = Field(max_length=300)
    descricao_completa: Optional[str] = Field(max_length=5000)
    preco_base: Decimal = Field(gt=0, decimal_places=2)
    categoria_id: UUID
    status: StatusProduto = StatusProduto.ATIVO
    
    # Metadados opcionais
    peso: Optional[Decimal] = Field(ge=0, decimal_places=3)
    dimensoes: Optional[Dict[str, float]] = None
    marca: Optional[str] = Field(max_length=100)
    
    # SEO
    meta_title: Optional[str] = Field(max_length=60)
    meta_description: Optional[str] = Field(max_length=160)
    
    @validator('dimensoes')
    @classmethod
    def validar_dimensoes(cls, v: Optional[Dict[str, float]]) -> Optional[Dict[str, float]]:
        """Valida estrutura das dimensÃµes."""
        if v is None:
            return v
        
        campos_obrigatorios = {'altura', 'largura', 'profundidade'}
        if not campos_obrigatorios.issubset(v.keys()):
            raise ValueError(f"DimensÃµes devem conter: {campos_obrigatorios}")
        
        for campo, valor in v.items():
            if valor <= 0:
                raise ValueError(f"DimensÃ£o {campo} deve ser positiva")
        
        return v
    
    @validator('preco_base')
    @classmethod
    def validar_preco(cls, v: Decimal) -> Decimal:
        """Valida formato do preÃ§o."""
        if v.as_tuple().exponent < -2:
            raise ValueError("PreÃ§o nÃ£o pode ter mais de 2 casas decimais")
        return v
    
    class Config:
        from_attributes = True
        json_encoders = {
            Decimal: lambda v: float(v),
            UUID: lambda v: str(v)
        }


class VariacaoSchema(BaseModel):
    """Schema para variaÃ§Ã£o de produto."""
    
    id: Optional[UUID] = None
    produto_id: UUID
    sku: str = Field(min_length=3, max_length=50)
    atributos: Dict[str, str] = Field(min_items=1)
    preco: Optional[Decimal] = Field(gt=0, decimal_places=2)
    estoque_atual: int = Field(ge=0)
    estoque_minimo: int = Field(ge=0, default=5)
    ativo: bool = True
    
    @validator('atributos')
    @classmethod
    def validar_atributos(cls, v: Dict[str, str]) -> Dict[str, str]:
        """Valida atributos da variaÃ§Ã£o."""
        if not v:
            raise ValueError("VariaÃ§Ã£o deve ter pelo menos um atributo")
        
        # Validar que valores nÃ£o estÃ£o vazios
        for chave, valor in v.items():
            if not valor.strip():
                raise ValueError(f"Valor do atributo '{chave}' nÃ£o pode estar vazio")
        
        return v
    
    @validator('sku')
    @classmethod
    def validar_sku(cls, v: str) -> str:
        """Valida formato do SKU."""
        if not v.replace('-', '').replace('_', '').isalnum():
            raise ValueError("SKU deve conter apenas letras, nÃºmeros, hÃ­fens e underscores")
        return v.upper()
    
    class Config:
        from_attributes = True
```

#### Sistema de Carrinho AvanÃ§ado
```python
# ecommerce/domains/carrinho/models.py
from decimal import Decimal
from datetime import datetime, timedelta
from typing import List, Optional, Dict
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, validator
from sqlalchemy import Column, String, Integer, Numeric, DateTime, Boolean, JSON
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import relationship

from ...infrastructure.database.base import Base


class StatusCarrinho(str, Enum):
    """Status do carrinho de compras."""
    ATIVO = "ativo"
    ABANDONADO = "abandonado"
    CONVERTIDO = "convertido"
    EXPIRADO = "expirado"


class Carrinho(Base):
    """Carrinho de compras do usuÃ¡rio."""
    __tablename__ = "carrinhos"
    
    id = Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid4)
    usuario_id = Column(PG_UUID(as_uuid=True), nullable=True)  # Pode ser anÃ´nimo
    session_id = Column(String(100), nullable=True)  # Para usuÃ¡rios nÃ£o logados
    
    # Valores calculados
    subtotal = Column(Numeric(10, 2), default=0)
    desconto = Column(Numeric(10, 2), default=0)
    frete = Column(Numeric(10, 2), default=0)
    total = Column(Numeric(10, 2), default=0)
    
    # Cupons e promoÃ§Ãµes aplicados
    cupom_codigo = Column(String(50))
    cupom_desconto = Column(Numeric(10, 2), default=0)
    
    # Status e controle
    status = Column(String(20), default=StatusCarrinho.ATIVO)
    
    # Dados de entrega
    cep_destino = Column(String(10))
    dados_frete = Column(JSON)  # Resultado do cÃ¡lculo de frete
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    expires_at = Column(DateTime, default=lambda: datetime.utcnow() + timedelta(days=30))
    
    # Relacionamentos
    itens = relationship("ItemCarrinho", back_populates="carrinho", cascade="all, delete-orphan")


class ItemCarrinho(Base):
    """Item especÃ­fico dentro do carrinho."""
    __tablename__ = "itens_carrinho"
    
    id = Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid4)
    carrinho_id = Column(PG_UUID(as_uuid=True), nullable=False)
    variacao_id = Column(PG_UUID(as_uuid=True), nullable=False)
    
    # Dados do produto no momento da adiÃ§Ã£o
    produto_nome = Column(String(200), nullable=False)
    produto_sku = Column(String(50), nullable=False)
    atributos_variacao = Column(JSON)  # Snapshot dos atributos
    
    # PreÃ§os e quantidades
    preco_unitario = Column(Numeric(10, 2), nullable=False)
    preco_original = Column(Numeric(10, 2))  # Para mostrar desconto
    quantidade = Column(Integer, nullable=False)
    subtotal = Column(Numeric(10, 2), nullable=False)
    
    # Relacionamentos
    carrinho = relationship("Carrinho", back_populates="itens")
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class CarrinhoService:
    """ServiÃ§o de negÃ³cio para gestÃ£o de carrinho."""
    
    def __init__(self, carrinho_repo, produto_repo, estoque_service, cupom_service):
        self._carrinho_repo = carrinho_repo
        self._produto_repo = produto_repo
        self._estoque_service = estoque_service
        self._cupom_service = cupom_service
    
    async def adicionar_item(
        self,
        carrinho_id: UUID,
        variacao_id: UUID,
        quantidade: int
    ) -> ItemCarrinho:
        """
        Adiciona item ao carrinho com validaÃ§Ãµes completas.
        
        ValidaÃ§Ãµes aplicadas:
        - Produto existe e estÃ¡ ativo
        - VariaÃ§Ã£o disponÃ­vel
        - Estoque suficiente
        - Quantidade vÃ¡lida
        - Limites por item
        
        Args:
            carrinho_id: ID do carrinho
            variacao_id: ID da variaÃ§Ã£o do produto
            quantidade: Quantidade desejada
            
        Returns:
            Item adicionado ao carrinho
            
        Raises:
            EstoqueInsuficienteError: Se nÃ£o hÃ¡ estoque
            ProdutoInativoError: Se produto nÃ£o estÃ¡ disponÃ­vel
            QuantidadeInvalidaError: Se quantidade Ã© invÃ¡lida
        """
        # IMPLEMENTAR: LÃ³gica completa de adiÃ§Ã£o
        # 1. Validar carrinho existe e estÃ¡ ativo
        # 2. Buscar e validar variaÃ§Ã£o do produto
        # 3. Verificar disponibilidade em estoque
        # 4. Verificar se item jÃ¡ existe (atualizar quantidade)
        # 5. Aplicar limites de quantidade
        # 6. Calcular preÃ§os e descontos
        # 7. Atualizar totais do carrinho
        pass
    
    async def atualizar_quantidade(
        self,
        item_id: UUID,
        nova_quantidade: int
    ) -> ItemCarrinho:
        """
        Atualiza quantidade de um item no carrinho.
        
        Args:
            item_id: ID do item
            nova_quantidade: Nova quantidade (0 remove o item)
            
        Returns:
            Item atualizado ou None se removido
        """
        # IMPLEMENTAR: LÃ³gica de atualizaÃ§Ã£o com validaÃ§Ãµes
        pass
    
    async def aplicar_cupom(
        self,
        carrinho_id: UUID,
        codigo_cupom: str
    ) -> Carrinho:
        """
        Aplica cupom de desconto ao carrinho.
        
        Args:
            carrinho_id: ID do carrinho
            codigo_cupom: CÃ³digo do cupom
            
        Returns:
            Carrinho com cupom aplicado
            
        Raises:
            CupomInvalidoError: Se cupom nÃ£o Ã© vÃ¡lido
            CupomExpiradoError: Se cupom expirou
            CupomJaUtilizadoError: Se cupom jÃ¡ foi usado
        """
        # IMPLEMENTAR: ValidaÃ§Ã£o e aplicaÃ§Ã£o de cupom
        pass
    
    async def calcular_frete(
        self,
        carrinho_id: UUID,
        cep_destino: str,
        tipo_entrega: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Calcula opÃ§Ãµes de frete para o carrinho.
        
        Args:
            carrinho_id: ID do carrinho
            cep_destino: CEP de destino
            tipo_entrega: Tipo preferido de entrega
            
        Returns:
            DicionÃ¡rio com opÃ§Ãµes de frete
        """
        # IMPLEMENTAR: IntegraÃ§Ã£o com APIs de frete
        pass
    
    async def finalizar_carrinho(self, carrinho_id: UUID) -> Dict[str, Any]:
        """
        Prepara carrinho para checkout final.
        
        ValidaÃ§Ãµes finais:
        - Estoque ainda disponÃ­vel
        - PreÃ§os nÃ£o alterados
        - Cupons ainda vÃ¡lidos
        - Dados de entrega vÃ¡lidos
        
        Args:
            carrinho_id: ID do carrinho
            
        Returns:
            Resumo final do carrinho
        """
        # IMPLEMENTAR: ValidaÃ§Ãµes finais e preparaÃ§Ã£o para checkout
        pass


# Schema para validaÃ§Ã£o e serializaÃ§Ã£o
class CarrinhoSchema(BaseModel):
    """Schema do carrinho para API."""
    
    id: UUID
    usuario_id: Optional[UUID]
    subtotal: Decimal
    desconto: Decimal
    frete: Decimal
    total: Decimal
    cupom_codigo: Optional[str]
    status: StatusCarrinho
    itens: List['ItemCarrinhoSchema']
    
    created_at: datetime
    updated_at: datetime
    expires_at: datetime
    
    class Config:
        from_attributes = True


class ItemCarrinhoSchema(BaseModel):
    """Schema do item do carrinho."""
    
    id: UUID
    produto_nome: str
    produto_sku: str
    atributos_variacao: Dict[str, str]
    preco_unitario: Decimal
    preco_original: Optional[Decimal]
    quantidade: int
    subtotal: Decimal
    
    # Indica se hÃ¡ desconto
    @property
    def tem_desconto(self) -> bool:
        return (
            self.preco_original is not None 
            and self.preco_original > self.preco_unitario
        )
    
    # Percentual de desconto
    @property
    def percentual_desconto(self) -> Optional[float]:
        if not self.tem_desconto:
            return None
        return float((self.preco_original - self.preco_unitario) / self.preco_original * 100)
    
    class Config:
        from_attributes = True


# Atualizar referÃªncia forward
CarrinhoSchema.model_rebuild()
```

### Sistema de Pagamentos com Strategy Pattern

```python
# ecommerce/domains/pagamentos/services.py
from abc import ABC, abstractmethod
from decimal import Decimal
from enum import Enum
from typing import Dict, Any, Optional, List
from uuid import UUID, uuid4

from pydantic import BaseModel


class StatusPagamento(str, Enum):
    """Status de um pagamento."""
    PENDENTE = "pendente"
    PROCESSANDO = "processando"
    APROVADO = "aprovado"
    REJEITADO = "rejeitado"
    CANCELADO = "cancelado"
    ESTORNADO = "estornado"


class TipoPagamento(str, Enum):
    """Tipos de pagamento suportados."""
    CARTAO_CREDITO = "cartao_credito"
    CARTAO_DEBITO = "cartao_debito"
    PIX = "pix"
    BOLETO = "boleto"
    PAYPAL = "paypal"


class ResultadoPagamento(BaseModel):
    """Resultado de uma operaÃ§Ã£o de pagamento."""
    sucesso: bool
    transaction_id: Optional[str]
    gateway_response: Dict[str, Any]
    mensagem: Optional[str]
    codigo_erro: Optional[str]


class GatewayPagamento(ABC):
    """Interface abstrata para gateways de pagamento."""
    
    @abstractmethod
    async def processar_pagamento(
        self,
        valor: Decimal,
        dados_pagamento: Dict[str, Any],
        metadata: Optional[Dict[str, Any]] = None
    ) -> ResultadoPagamento:
        """Processa um pagamento."""
        pass
    
    @abstractmethod
    async def estornar_pagamento(
        self,
        transaction_id: str,
        valor: Optional[Decimal] = None
    ) -> ResultadoPagamento:
        """Estorna um pagamento."""
        pass
    
    @abstractmethod
    async def consultar_status(self, transaction_id: str) -> StatusPagamento:
        """Consulta status de uma transaÃ§Ã£o."""
        pass


class StripeGateway(GatewayPagamento):
    """ImplementaÃ§Ã£o para Stripe."""
    
    def __init__(self, api_key: str, webhook_secret: str):
        self.api_key = api_key
        self.webhook_secret = webhook_secret
        # Em implementaÃ§Ã£o real: inicializar cliente Stripe
    
    async def processar_pagamento(
        self,
        valor: Decimal,
        dados_pagamento: Dict[str, Any],
        metadata: Optional[Dict[str, Any]] = None
    ) -> ResultadoPagamento:
        """Processa pagamento via Stripe."""
        try:
            # SimulaÃ§Ã£o de integraÃ§Ã£o com Stripe
            # Em implementaÃ§Ã£o real:
            # import stripe
            # stripe.api_key = self.api_key
            # charge = stripe.Charge.create(...)
            
            # Para demonstraÃ§Ã£o, simula sucesso
            return ResultadoPagamento(
                sucesso=True,
                transaction_id=f"stripe_{uuid4().hex[:16]}",
                gateway_response={
                    "id": f"ch_{uuid4().hex[:24]}",
                    "amount": int(valor * 100),  # Stripe usa centavos
                    "currency": "brl",
                    "status": "succeeded"
                },
                mensagem="Pagamento processado com sucesso"
            )
        
        except Exception as e:
            return ResultadoPagamento(
                sucesso=False,
                transaction_id=None,
                gateway_response={"error": str(e)},
                mensagem="Erro ao processar pagamento",
                codigo_erro="STRIPE_ERROR"
            )
    
    async def estornar_pagamento(
        self,
        transaction_id: str,
        valor: Optional[Decimal] = None
    ) -> ResultadoPagamento:
        """Estorna pagamento no Stripe."""
        # IMPLEMENTAR: LÃ³gica de estorno
        pass
    
    async def consultar_status(self, transaction_id: str) -> StatusPagamento:
        """Consulta status no Stripe."""
        # IMPLEMENTAR: Consulta de status
        pass


class PayPalGateway(GatewayPagamento):
    """ImplementaÃ§Ã£o para PayPal."""
    
    def __init__(self, client_id: str, client_secret: str, sandbox: bool = True):
        self.client_id = client_id
        self.client_secret = client_secret
        self.sandbox = sandbox
    
    async def processar_pagamento(
        self,
        valor: Decimal,
        dados_pagamento: Dict[str, Any],
        metadata: Optional[Dict[str, Any]] = None
    ) -> ResultadoPagamento:
        """Processa pagamento via PayPal."""
        # IMPLEMENTAR: IntegraÃ§Ã£o com PayPal
        pass


class PagamentoService:
    """ServiÃ§o central de pagamentos usando Strategy Pattern."""
    
    def __init__(self):
        self._gateways: Dict[TipoPagamento, GatewayPagamento] = {}
        self._gateway_padrao = None
    
    def registrar_gateway(
        self,
        tipo: TipoPagamento,
        gateway: GatewayPagamento,
        padrao: bool = False
    ) -> None:
        """Registra um gateway de pagamento."""
        self._gateways[tipo] = gateway
        if padrao:
            self._gateway_padrao = tipo
    
    async def processar_pagamento(
        self,
        pedido_id: UUID,
        valor: Decimal,
        tipo_pagamento: TipoPagamento,
        dados_pagamento: Dict[str, Any],
        parcelas: int = 1
    ) -> ResultadoPagamento:
        """
        Processa pagamento usando gateway apropriado.
        
        Args:
            pedido_id: ID do pedido
            valor: Valor a ser cobrado
            tipo_pagamento: Tipo de pagamento
            dados_pagamento: Dados especÃ­ficos do pagamento
            parcelas: NÃºmero de parcelas
            
        Returns:
            Resultado do processamento
        """
        # ValidaÃ§Ãµes iniciais
        if valor <= 0:
            return ResultadoPagamento(
                sucesso=False,
                transaction_id=None,
                gateway_response={},
                mensagem="Valor invÃ¡lido",
                codigo_erro="INVALID_AMOUNT"
            )
        
        # Selecionar gateway
        gateway = self._gateways.get(tipo_pagamento)
        if not gateway:
            return ResultadoPagamento(
                sucesso=False,
                transaction_id=None,
                gateway_response={},
                mensagem=f"Gateway nÃ£o configurado para {tipo_pagamento}",
                codigo_erro="GATEWAY_NOT_FOUND"
            )
        
        # Preparar metadata
        metadata = {
            "pedido_id": str(pedido_id),
            "parcelas": parcelas,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        # Processar pagamento
        resultado = await gateway.processar_pagamento(
            valor, dados_pagamento, metadata
        )
        
        # Registrar transaÃ§Ã£o no banco de dados
        await self._registrar_transacao(
            pedido_id, valor, tipo_pagamento, resultado
        )
        
        return resultado
    
    async def _registrar_transacao(
        self,
        pedido_id: UUID,
        valor: Decimal,
        tipo_pagamento: TipoPagamento,
        resultado: ResultadoPagamento
    ) -> None:
        """Registra transaÃ§Ã£o no banco de dados."""
        # IMPLEMENTAR: PersistÃªncia da transaÃ§Ã£o
        pass


# Factory para configuraÃ§Ã£o dos gateways
class PagamentoFactory:
    """Factory para criar e configurar serviÃ§o de pagamentos."""
    
    @staticmethod
    def criar_servico_producao() -> PagamentoService:
        """Cria serviÃ§o configurado para produÃ§Ã£o."""
        servico = PagamentoService()
        
        # Configurar Stripe
        stripe_gateway = StripeGateway(
            api_key="sk_live_...",  # Chave real em produÃ§Ã£o
            webhook_secret="whsec_..."
        )
        servico.registrar_gateway(TipoPagamento.CARTAO_CREDITO, stripe_gateway, padrao=True)
        
        # Configurar PayPal
        paypal_gateway = PayPalGateway(
            client_id="client_id_real",
            client_secret="client_secret_real",
            sandbox=False
        )
        servico.registrar_gateway(TipoPagamento.PAYPAL, paypal_gateway)
        
        return servico
    
    @staticmethod
    def criar_servico_teste() -> PagamentoService:
        """Cria serviÃ§o configurado para testes."""
        servico = PagamentoService()
        
        # Usar mocks ou gateways de teste
        # IMPLEMENTAR: ConfiguraÃ§Ã£o para testes
        
        return servico
```

### Testes End-to-End Complexos

```python
# tests/e2e/test_user_journey.py
import pytest
from decimal import Decimal
from uuid import uuid4

from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from ecommerce.domains.usuarios.models import Usuario, TipoUsuario
from ecommerce.domains.produtos.models import Produto, VariacaoProduto
from ecommerce.domains.carrinho.models import Carrinho


class TestJornadaCompletalUsuario:
    """Testes end-to-end da jornada completa do usuÃ¡rio."""
    
    @pytest.mark.asyncio
    async def test_jornada_compra_completa(
        self,
        async_client: AsyncClient,
        db_session: AsyncSession,
        usuario_teste: Usuario,
        produto_teste: Produto
    ):
        """
        Testa jornada completa: registro â†’ busca â†’ carrinho â†’ checkout â†’ pagamento.
        
        Este teste simula uma jornada real de usuÃ¡rio desde o registro
        atÃ© a finalizaÃ§Ã£o da compra, validando cada etapa do processo.
        """
        
        # Etapa 1: Registro de usuÃ¡rio
        dados_registro = {
            "nome": "JoÃ£o Silva",
            "email": "joao@example.com",
            "senha": "SenhaSegura123!",
            "telefone": "11999999999"
        }
        
        response = await async_client.post("/api/usuarios/registro", json=dados_registro)
        assert response.status_code == 201
        usuario_data = response.json()
        usuario_id = usuario_data["id"]
        
        # Etapa 2: Login
        dados_login = {
            "email": "joao@example.com",
            "senha": "SenhaSegura123!"
        }
        
        response = await async_client.post("/api/auth/login", json=dados_login)
        assert response.status_code == 200
        
        token = response.json()["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        # Etapa 3: Buscar produtos
        response = await async_client.get(
            "/api/produtos/buscar",
            params={"q": "camiseta", "categoria": "roupas"},
            headers=headers
        )
        assert response.status_code == 200
        produtos = response.json()["items"]
        assert len(produtos) > 0
        
        produto_id = produtos[0]["id"]
        variacao_id = produtos[0]["variacoes"][0]["id"]
        
        # Etapa 4: Adicionar ao carrinho
        dados_item = {
            "variacao_id": variacao_id,
            "quantidade": 2
        }
        
        response = await async_client.post(
            "/api/carrinho/adicionar",
            json=dados_item,
            headers=headers
        )
        assert response.status_code == 200
        
        # Etapa 5: Visualizar carrinho
        response = await async_client.get("/api/carrinho", headers=headers)
        assert response.status_code == 200
        carrinho = response.json()
        assert len(carrinho["itens"]) == 1
        assert carrinho["itens"][0]["quantidade"] == 2
        
        carrinho_id = carrinho["id"]
        
        # Etapa 6: Aplicar cupom de desconto
        dados_cupom = {"codigo": "DESCONTO10"}
        response = await async_client.post(
            f"/api/carrinho/{carrinho_id}/cupom",
            json=dados_cupom,
            headers=headers
        )
        assert response.status_code == 200
        
        # Etapa 7: Calcular frete
        dados_frete = {"cep": "01310-100"}
        response = await async_client.post(
            f"/api/carrinho/{carrinho_id}/frete",
            json=dados_frete,
            headers=headers
        )
        assert response.status_code == 200
        opcoes_frete = response.json()
        assert len(opcoes_frete["opcoes"]) > 0
        
        # Selecionar opÃ§Ã£o de frete
        frete_selecionado = opcoes_frete["opcoes"][0]
        response = await async_client.put(
            f"/api/carrinho/{carrinho_id}/frete",
            json={"opcao_id": frete_selecionado["id"]},
            headers=headers
        )
        assert response.status_code == 200
        
        # Etapa 8: Iniciar checkout
        endereco_entrega = {
            "cep": "01310-100",
            "logradouro": "Rua Augusta, 123",
            "bairro": "ConsolaÃ§Ã£o",
            "cidade": "SÃ£o Paulo",
            "estado": "SP",
            "complemento": "Apto 45"
        }
        
        dados_checkout = {
            "endereco_entrega": endereco_entrega,
            "endereco_cobranca": endereco_entrega  # Mesmo endereÃ§o
        }
        
        response = await async_client.post(
            f"/api/carrinho/{carrinho_id}/checkout",
            json=dados_checkout,
            headers=headers
        )
        assert response.status_code == 200
        checkout_data = response.json()
        pedido_id = checkout_data["pedido_id"]
        
        # Etapa 9: Processar pagamento
        dados_pagamento = {
            "tipo": "cartao_credito",
            "cartao": {
                "numero": "4111111111111111",  # NÃºmero de teste Visa
                "nome": "JOAO SILVA",
                "mes": "12",
                "ano": "2025",
                "cvv": "123"
            },
            "parcelas": 1
        }
        
        response = await async_client.post(
            f"/api/pedidos/{pedido_id}/pagamento",
            json=dados_pagamento,
            headers=headers
        )
        assert response.status_code == 200
        pagamento_data = response.json()
        assert pagamento_data["status"] == "aprovado"
        
        # Etapa 10: Confirmar pedido final
        response = await async_client.get(f"/api/pedidos/{pedido_id}", headers=headers)
        assert response.status_code == 200
        pedido_final = response.json()
        
        # ValidaÃ§Ãµes finais
        assert pedido_final["status"] == "confirmado"
        assert pedido_final["total"] > 0
        assert len(pedido_final["itens"]) == 1
        assert pedido_final["endereco_entrega"]["cep"] == "01310-100"
        assert pedido_final["pagamento"]["status"] == "aprovado"
        
        # Verificar que carrinho foi limpo
        response = await async_client.get("/api/carrinho", headers=headers)
        carrinho_pos_compra = response.json()
        assert len(carrinho_pos_compra["itens"]) == 0
    
    @pytest.mark.asyncio
    async def test_jornada_abandono_carrinho(
        self,
        async_client: AsyncClient,
        usuario_teste: Usuario
    ):
        """Testa cenÃ¡rio de abandono de carrinho e recuperaÃ§Ã£o."""
        # IMPLEMENTAR: Teste de abandono e recuperaÃ§Ã£o de carrinho
        pass
    
    @pytest.mark.asyncio
    async def test_jornada_pagamento_rejeitado(
        self,
        async_client: AsyncClient,
        usuario_teste: Usuario
    ):
        """Testa cenÃ¡rio onde pagamento Ã© rejeitado."""
        # IMPLEMENTAR: Teste de pagamento rejeitado
        pass


class TestJornadaAdmin:
    """Testes da jornada do administrador."""
    
    @pytest.mark.asyncio
    async def test_gestao_completa_produto(
        self,
        async_client: AsyncClient,
        admin_user: Usuario
    ):
        """Testa gestÃ£o completa de produto: criar â†’ editar â†’ ativar/desativar."""
        # IMPLEMENTAR: Teste de gestÃ£o de produtos
        pass
    
    @pytest.mark.asyncio
    async def test_processamento_pedidos(
        self,
        async_client: AsyncClient,
        admin_user: Usuario
    ):
        """Testa processamento de pedidos pelo admin."""
        # IMPLEMENTAR: Teste de processamento de pedidos
        pass


class TestPerformance:
    """Testes de performance e carga."""
    
    @pytest.mark.asyncio
    @pytest.mark.slow
    async def test_carga_multiplos_usuarios(
        self,
        async_client: AsyncClient
    ):
        """Simula mÃºltiplos usuÃ¡rios fazendo compras simultaneamente."""
        import asyncio
        
        async def simular_compra(user_id: int):
            """Simula uma compra completa para um usuÃ¡rio."""
            # IMPLEMENTAR: SimulaÃ§Ã£o de compra com dados Ãºnicos
            pass
        
        # Executar 50 compras simultÃ¢neas
        tasks = [simular_compra(i) for i in range(50)]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Verificar que pelo menos 90% tiveram sucesso
        sucessos = sum(1 for r in results if not isinstance(r, Exception))
        assert sucessos >= 45  # 90% de sucesso
    
    @pytest.mark.asyncio
    async def test_performance_busca_produtos(
        self,
        async_client: AsyncClient,
        produtos_massa: List[Produto]  # Fixture com 1000+ produtos
    ):
        """Testa performance da busca com grande volume de produtos."""
        import time
        
        start_time = time.time()
        
        response = await async_client.get(
            "/api/produtos/buscar",
            params={"q": "teste", "limit": 20}
        )
        
        end_time = time.time()
        response_time = end_time - start_time
        
        assert response.status_code == 200
        assert response_time < 0.5  # Menos de 500ms
        
        results = response.json()
        assert len(results["items"]) <= 20
```

### CritÃ©rios de AvaliaÃ§Ã£o Detalhados

#### Arquitetura e Design (25%)
- [ ] **Domain-Driven Design**: DomÃ­nios bem separados e coesos
- [ ] **Patterns Aplicados**: Strategy, Factory, Repository, etc.
- [ ] **SeparaÃ§Ã£o de Responsabilidades**: API, DomÃ­nio, Infraestrutura
- [ ] **Extensibilidade**: Facilidade para adicionar novos recursos
- [ ] **Configurabilidade**: Ambiente, gateways, features toggles

#### Qualidade de CÃ³digo (25%)
- [ ] **Type Safety**: Tipagem completa e consistente
- [ ] **ValidaÃ§Ãµes**: Entrada, negÃ³cio, integridade
- [ ] **Error Handling**: Tratamento robusto de exceÃ§Ãµes
- [ ] **Code Quality**: Ruff, mypy, complexidade ciclomÃ¡tica
- [ ] **DocumentaÃ§Ã£o**: Docstrings, README, API docs

#### Funcionalidades (25%)
- [ ] **Features Completas**: Todos os requisitos implementados
- [ ] **Regras de NegÃ³cio**: ValidaÃ§Ãµes corretas e completas
- [ ] **IntegraÃ§Ãµes**: APIs externas, gateways de pagamento
- [ ] **Performance**: Tempo de resposta adequado
- [ ] **Usabilidade**: Interface intuitiva e responsiva

#### Testes e DevOps (25%)
- [ ] **Cobertura**: >= 90% para domÃ­nios crÃ­ticos
- [ ] **Tipos de Teste**: Unit, integration, e2e
- [ ] **Qualidade dos Testes**: CenÃ¡rios reais, edge cases
- [ ] **CI/CD**: Pipeline completo funcionando
- [ ] **Monitoramento**: Logs, mÃ©tricas, health checks

### ExtensÃµes AvanÃ§adas

#### Observabilidade
- IntegraÃ§Ã£o com Prometheus/Grafana
- Distributed tracing com OpenTelemetry
- Alertas automÃ¡ticos para mÃ©tricas crÃ­ticas
- Dashboard de negÃ³cio em tempo real

#### Escalabilidade
- Cache distribuÃ­do com Redis Cluster
- Message broker para processamento assÃ­ncrono
- Read replicas para consultas
- CDN para assets estÃ¡ticos

#### SeguranÃ§a
- AutenticaÃ§Ã£o JWT com refresh tokens
- Rate limiting por usuÃ¡rio/IP
- ValidaÃ§Ã£o de entrada rigorosa
- Auditoria de aÃ§Ãµes crÃ­ticas
- HTTPS only com certificados vÃ¡lidos

### Tempo Estimado e Entregas

**Fase 1 (Semana 1-2)**: Arquitetura e Modelos
- Setup do projeto e estrutura
- Modelos de domÃ­nio principais
- RepositÃ³rios e serviÃ§os bÃ¡sicos
- Testes unitÃ¡rios dos modelos

**Fase 2 (Semana 3-4)**: API e IntegraÃ§Ãµes
- Endpoints REST completos
- IntegraÃ§Ã£o com gateways de pagamento
- Sistema de carrinho e checkout
- Testes de integraÃ§Ã£o

**Fase 3 (Semana 5-6)**: Interface e DevOps
- Frontend/admin interface
- Pipeline CI/CD completo
- Monitoramento e logs
- Testes end-to-end

**Entrega Final**: DemonstraÃ§Ã£o completa com:
- AplicaÃ§Ã£o rodando em produÃ§Ã£o
- Pipeline CI/CD funcional
- DocumentaÃ§Ã£o completa
- MÃ©tricas de performance
- ApresentaÃ§Ã£o tÃ©cnica (30 min)

Este exercÃ­cio representa o nÃ­vel mÃ¡ximo de complexidade esperado, integrando todos os conceitos abordados na disciplina em um projeto real e pronto para produÃ§Ã£o.

# üî¥ Exerc√≠cios N√≠vel 3 - Avan√ßado

## Exerc√≠cio 3.1: Sistema Banc√°rio com Arquitetura Hexagonal (3-4 horas)

### üìã Descri√ß√£o
Desenvolva um sistema banc√°rio completo aplicando **Arquitetura Hexagonal (Ports & Adapters)**, **Domain-Driven Design (DDD)**, e m√∫ltiplos **Design Patterns** em uma solu√ß√£o empresarial robusta.

### üéØ Cen√°rio de Neg√≥cio
Implemente um sistema banc√°rio que suporte:
- Gest√£o de contas (Corrente, Poupan√ßa, Investimento)
- Transa√ß√µes complexas (Transfer√™ncias, PIX, TED, DOC)
- Processamento de empr√©stimos com an√°lise de risco
- Notifica√ß√µes multicanal em tempo real
- Auditoria completa de opera√ß√µes
- Integra√ß√£o com servi√ßos externos (Bacen, SPC, Serasa)

### üèóÔ∏è Arquitetura Hexagonal Requerida

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        ADAPTERS (Infrastructure)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Web API    ‚îÇ  CLI    ‚îÇ  Database  ‚îÇ  External APIs  ‚îÇ Queue ‚îÇ
‚îÇ  (FastAPI)  ‚îÇ (Click) ‚îÇ (SQLAlch.) ‚îÇ (HTTP/gRPC)    ‚îÇ(Redis)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ                PORTS                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     APPLICATION LAYER                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Use Cases    ‚îÇ   Command/Query Handlers  ‚îÇ   Events     ‚îÇ
‚îÇ   (Services)     ‚îÇ      (CQRS Pattern)       ‚îÇ (Observers)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ              DOMAIN               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      DOMAIN LAYER                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Entities  ‚îÇ Value Objects ‚îÇ Domain Services ‚îÇ Repositories ‚îÇ
‚îÇ (Agregates)‚îÇ   (Immutable) ‚îÇ   (Pure Logic)  ‚îÇ (Interfaces) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üìã Requisitos Funcionais Complexos

#### **RF001 - Gest√£o de Contas**
- Criar conta com valida√ß√£o de documentos
- Aplicar regras espec√≠ficas por tipo de conta
- Controlar limites e saldos em tempo real
- Hist√≥rico completo de altera√ß√µes

#### **RF002 - Transa√ß√µes Avan√ßadas**
- Transfer√™ncias com valida√ß√£o de fundos
- PIX instant√¢neo com chave e QR Code
- TED/DOC com agendamento
- Estorno autom√°tico em caso de falha

#### **RF003 - Sistema de Empr√©stimos**
- An√°lise de risco baseada em score
- Simula√ß√£o de parcelas com diferentes taxas
- Aprova√ß√£o autom√°tica/manual baseada em regras
- Controle de inadimpl√™ncia

#### **RF004 - Auditoria e Compliance**
- Log de todas as opera√ß√µes
- Rastreabilidade completa
- Relat√≥rios regulat√≥rios
- Detec√ß√£o de fraudes

### üìã Requisitos T√©cnicos

#### **Padr√µes de Design Obrigat√≥rios:**
- **Command Pattern**: Para opera√ß√µes transacionais
- **Strategy Pattern**: Para c√°lculo de juros e taxas
- **Factory Pattern**: Para cria√ß√£o de diferentes tipos de conta
- **Observer Pattern**: Para notifica√ß√µes e auditoria
- **State Pattern**: Para status de transa√ß√µes
- **Specification Pattern**: Para regras de neg√≥cio complexas
- **Repository Pattern**: Para persist√™ncia
- **Unit of Work**: Para controle transacional

#### **Princ√≠pios Arquiteturais:**
- **Domain-Driven Design**: Linguagem ub√≠qua e bounded contexts
- **CQRS**: Separa√ß√£o de comandos e consultas
- **Event Sourcing**: Para auditoria (opcional avan√ßado)
- **Dependency Injection**: Invers√£o de controle completa

### üíª Estrutura Base da Solu√ß√£o

```python
# =============================================================================
# DOMAIN LAYER - N√∫cleo da aplica√ß√£o, independente de frameworks
# =============================================================================

from abc import ABC, abstractmethod
from dataclasses import dataclass
from decimal import Decimal
from datetime import datetime
from typing import List, Optional, Protocol
from enum import Enum
import uuid

# Value Objects (Imut√°veis, sem identidade)
@dataclass(frozen=True)
class CPF:
    """Value Object para CPF com valida√ß√£o"""
    numero: str
    
    def __post_init__(self):
        if not self._validar_cpf(self.numero):
            raise ValueError(f"CPF inv√°lido: {self.numero}")
    
    def _validar_cpf(self, cpf: str) -> bool:
        # TODO: Implementar valida√ß√£o real de CPF
        return len(cpf) == 11 and cpf.isdigit()

@dataclass(frozen=True)
class Dinheiro:
    """Value Object para representar valores monet√°rios"""
    valor: Decimal
    moeda: str = "BRL"
    
    def __post_init__(self):
        if self.valor < 0:
            raise ValueError("Valor n√£o pode ser negativo")
    
    def somar(self, outro: 'Dinheiro') -> 'Dinheiro':
        if self.moeda != outro.moeda:
            raise ValueError("Moedas diferentes")
        return Dinheiro(self.valor + outro.valor, self.moeda)
    
    def subtrair(self, outro: 'Dinheiro') -> 'Dinheiro':
        if self.moeda != outro.moeda:
            raise ValueError("Moedas diferentes")
        resultado = self.valor - outro.valor
        return Dinheiro(resultado, self.moeda)

# Enums para o dom√≠nio
class TipoConta(Enum):
    CORRENTE = "corrente"
    POUPANCA = "poupanca"
    INVESTIMENTO = "investimento"

class StatusTransacao(Enum):
    PENDENTE = "pendente"
    PROCESSANDO = "processando"
    CONCLUIDA = "concluida"
    FALHADA = "falhada"
    ESTORNADA = "estornada"

class TipoTransacao(Enum):
    DEPOSITO = "deposito"
    SAQUE = "saque"
    TRANSFERENCIA = "transferencia"
    PIX = "pix"
    TED = "ted"
    DOC = "doc"

# Domain Events
@dataclass(frozen=True)
class EventoDominio:
    """Evento base do dom√≠nio"""
    id: str
    timestamp: datetime
    agregado_id: str

@dataclass(frozen=True)
class ContaCriada(EventoDominio):
    cpf_titular: str
    tipo_conta: TipoConta
    saldo_inicial: Decimal

@dataclass(frozen=True)
class TransacaoRealizada(EventoDominio):
    conta_origem: str
    conta_destino: Optional[str]
    tipo: TipoTransacao
    valor: Decimal
    status: StatusTransacao

# Especifica√ß√µes para regras de neg√≥cio complexas
class EspecificacaoNegocio(ABC):
    """Base para Specification Pattern"""
    
    @abstractmethod
    def satisfeita_por(self, candidate) -> bool:
        pass
    
    def e(self, other: 'EspecificacaoNegocio') -> 'EspecificacaoE':
        return EspecificacaoE(self, other)
    
    def ou(self, other: 'EspecificacaoNegocio') -> 'EspecificacaoOu':
        return EspecificacaoOu(self, other)

class EspecificacaoE(EspecificacaoNegocio):
    def __init__(self, left: EspecificacaoNegocio, right: EspecificacaoNegocio):
        self.left = left
        self.right = right
    
    def satisfeita_por(self, candidate) -> bool:
        return self.left.satisfeita_por(candidate) and self.right.satisfeita_por(candidate)

class EspecificacaoOu(EspecificacaoNegocio):
    def __init__(self, left: EspecificacaoNegocio, right: EspecificacaoNegocio):
        self.left = left
        self.right = right
    
    def satisfeita_por(self, candidate) -> bool:
        return self.left.satisfeita_por(candidate) or self.right.satisfeita_por(candidate)

# TODO: Implementar especifica√ß√µes espec√≠ficas
class ContaTemSaldoSuficiente(EspecificacaoNegocio):
    """Especifica√ß√£o para verificar saldo suficiente"""
    def __init__(self, valor_minimo: Dinheiro):
        self.valor_minimo = valor_minimo
    
    def satisfeita_por(self, conta) -> bool:
        # TODO: Implementar l√≥gica
        pass

class ClienteElegiveEmprestimo(EspecificacaoNegocio):
    """Especifica√ß√£o complexa para elegibilidade de empr√©stimo"""
    def __init__(self, score_minimo: int, renda_minima: Dinheiro):
        self.score_minimo = score_minimo
        self.renda_minima = renda_minima
    
    def satisfeita_por(self, cliente) -> bool:
        # TODO: Implementar regras complexas
        pass

# Entidades e Agregados
class Conta:
    """Agregado raiz para opera√ß√µes banc√°rias"""
    
    def __init__(self, numero: str, cpf_titular: CPF, tipo: TipoConta, 
                 saldo_inicial: Dinheiro = Dinheiro(Decimal("0"))):
        self.numero = numero
        self.cpf_titular = cpf_titular
        self.tipo = tipo
        self._saldo = saldo_inicial
        self._ativa = True
        self._limite = self._calcular_limite_inicial()
        self._historico: List[TransacaoRealizada] = []
        self._eventos: List[EventoDominio] = []
        
        # Registrar evento de cria√ß√£o
        self._registrar_evento(ContaCriada(
            id=str(uuid.uuid4()),
            timestamp=datetime.now(),
            agregado_id=self.numero,
            cpf_titular=cpf_titular.numero,
            tipo_conta=tipo,
            saldo_inicial=saldo_inicial.valor
        ))
    
    @property
    def saldo(self) -> Dinheiro:
        return self._saldo
    
    @property
    def ativa(self) -> bool:
        return self._ativa
    
    def debitar(self, valor: Dinheiro, especificacao: EspecificacaoNegocio = None) -> bool:
        """Debita valor da conta aplicando regras de neg√≥cio"""
        if not self._ativa:
            raise ValueError("Conta inativa")
        
        if especificacao and not especificacao.satisfeita_por(self):
            return False
        
        if self._saldo.valor < valor.valor:
            return False
        
        self._saldo = self._saldo.subtrair(valor)
        return True
    
    def creditar(self, valor: Dinheiro) -> None:
        """Credita valor na conta"""
        if not self._ativa:
            raise ValueError("Conta inativa")
        
        self._saldo = self._saldo.somar(valor)
    
    def _calcular_limite_inicial(self) -> Dinheiro:
        """Calcula limite baseado no tipo de conta"""
        limites = {
            TipoConta.CORRENTE: Dinheiro(Decimal("1000")),
            TipoConta.POUPANCA: Dinheiro(Decimal("0")),
            TipoConta.INVESTIMENTO: Dinheiro(Decimal("5000"))
        }
        return limites.get(self.tipo, Dinheiro(Decimal("0")))
    
    def _registrar_evento(self, evento: EventoDominio) -> None:
        """Registra evento para posterior publica√ß√£o"""
        self._eventos.append(evento)
    
    def obter_eventos_nao_publicados(self) -> List[EventoDominio]:
        """Retorna eventos n√£o publicados"""
        return self._eventos.copy()
    
    def marcar_eventos_como_publicados(self) -> None:
        """Marca eventos como publicados"""
        self._eventos.clear()

# TODO: Implementar Transacao como entidade
class Transacao:
    """Entidade que representa uma transa√ß√£o banc√°ria"""
    
    def __init__(self, tipo: TipoTransacao, valor: Dinheiro, 
                 conta_origem: str, conta_destino: Optional[str] = None):
        self.id = str(uuid.uuid4())
        self.tipo = tipo
        self.valor = valor
        self.conta_origem = conta_origem
        self.conta_destino = conta_destino
        self.status = StatusTransacao.PENDENTE
        self.timestamp_criacao = datetime.now()
        self.timestamp_conclusao: Optional[datetime] = None
        self._historico_status: List[tuple] = []
    
    def alterar_status(self, novo_status: StatusTransacao) -> None:
        """Altera status da transa√ß√£o (State Pattern)"""
        # TODO: Implementar State Pattern para transi√ß√µes v√°lidas
        pass
    
    def pode_ser_estornada(self) -> bool:
        """Verifica se transa√ß√£o pode ser estornada"""
        # TODO: Implementar regras de estorno
        pass

# =============================================================================
# APPLICATION LAYER - Casos de uso e orquestra√ß√£o
# =============================================================================

# Ports (Interfaces)
class RepositorioConta(Protocol):
    """Port para persist√™ncia de contas"""
    
    def salvar(self, conta: Conta) -> None: ...
    def buscar_por_numero(self, numero: str) -> Optional[Conta]: ...
    def buscar_por_cpf(self, cpf: CPF) -> List[Conta]: ...

class RepositorioTransacao(Protocol):
    """Port para persist√™ncia de transa√ß√µes"""
    
    def salvar(self, transacao: Transacao) -> None: ...
    def buscar_por_id(self, id: str) -> Optional[Transacao]: ...
    def buscar_por_conta(self, numero_conta: str) -> List[Transacao]: ...

class ServicoNotificacao(Protocol):
    """Port para servi√ßo de notifica√ß√µes"""
    
    def enviar_notificacao(self, destinatario: str, mensagem: str, canal: str) -> bool: ...

class ServicoAntifrude(Protocol):
    """Port para servi√ßo de detec√ß√£o de fraudes"""
    
    def analisar_transacao(self, transacao: Transacao) -> bool: ...

class UnidadeTrabalho(Protocol):
    """Port para Unit of Work pattern"""
    
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...

# Commands (CQRS)
@dataclass
class ComandoCriarConta:
    cpf: str
    tipo: TipoConta
    saldo_inicial: Decimal

@dataclass
class ComandoRealizarTransferencia:
    conta_origem: str
    conta_destino: str
    valor: Decimal
    tipo: TipoTransacao = TipoTransacao.TRANSFERENCIA

# Command Handlers
class ManipuladorComandoCriarConta:
    """Handler para cria√ß√£o de conta (Command Pattern)"""
    
    def __init__(self, repo_conta: RepositorioConta, 
                 servico_notificacao: ServicoNotificacao,
                 unidade_trabalho: UnidadeTrabalho):
        self._repo_conta = repo_conta
        self._servico_notificacao = servico_notificacao
        self._unidade_trabalho = unidade_trabalho
    
    def handle(self, comando: ComandoCriarConta) -> str:
        """Processa comando de cria√ß√£o de conta"""
        with self._unidade_trabalho:
            # Validar CPF
            cpf = CPF(comando.cpf)
            
            # Verificar se j√° existe conta
            contas_existentes = self._repo_conta.buscar_por_cpf(cpf)
            if len(contas_existentes) >= 3:  # Regra de neg√≥cio: m√°x 3 contas
                raise ValueError("Cliente j√° possui n√∫mero m√°ximo de contas")
            
            # Criar conta
            numero_conta = self._gerar_numero_conta()
            saldo_inicial = Dinheiro(comando.saldo_inicial)
            conta = Conta(numero_conta, cpf, comando.tipo, saldo_inicial)
            
            # Salvar
            self._repo_conta.salvar(conta)
            
            # Publicar eventos
            self._publicar_eventos(conta)
            
            self._unidade_trabalho.commit()
            return numero_conta
    
    def _gerar_numero_conta(self) -> str:
        """Gera n√∫mero √∫nico de conta"""
        # TODO: Implementar gera√ß√£o de n√∫mero √∫nico
        return str(uuid.uuid4())[:8]
    
    def _publicar_eventos(self, conta: Conta) -> None:
        """Publica eventos do agregado"""
        eventos = conta.obter_eventos_nao_publicados()
        for evento in eventos:
            # TODO: Publicar evento (Observer Pattern)
            pass
        conta.marcar_eventos_como_publicados()

# TODO: Implementar outros handlers
class ManipuladorComandoTransferencia:
    """Handler para transfer√™ncias (Command Pattern + Strategy)"""
    
    def __init__(self, repo_conta: RepositorioConta, 
                 repo_transacao: RepositorioTransacao,
                 servico_antifrude: ServicoAntifrude,
                 unidade_trabalho: UnidadeTrabalho):
        self._repo_conta = repo_conta
        self._repo_transacao = repo_transacao
        self._servico_antifrude = servico_antifrude
        self._unidade_trabalho = unidade_trabalho
    
    def handle(self, comando: ComandoRealizarTransferencia) -> str:
        """Processa transfer√™ncia entre contas"""
        # TODO: Implementar l√≥gica completa de transfer√™ncia
        # 1. Validar contas origem e destino
        # 2. Verificar saldo suficiente
        # 3. An√°lise antifraude
        # 4. Executar d√©bito e cr√©dito
        # 5. Registrar transa√ß√£o
        # 6. Publicar eventos
        pass

# =============================================================================
# INFRASTRUCTURE LAYER - Adapters para mundo externo
# =============================================================================

# Adaptadores de Persist√™ncia
class RepositorioContaMemoria:
    """Adapter: Reposit√≥rio em mem√≥ria para testes"""
    
    def __init__(self):
        self._contas: dict[str, Conta] = {}
    
    def salvar(self, conta: Conta) -> None:
        self._contas[conta.numero] = conta
    
    def buscar_por_numero(self, numero: str) -> Optional[Conta]:
        return self._contas.get(numero)
    
    def buscar_por_cpf(self, cpf: CPF) -> List[Conta]:
        return [conta for conta in self._contas.values() 
                if conta.cpf_titular == cpf]

# TODO: Implementar adaptadores SQL
class RepositorioContaSQL:
    """Adapter: Reposit√≥rio SQL com SQLAlchemy"""
    
    def __init__(self, session):
        self._session = session
    
    def salvar(self, conta: Conta) -> None:
        # TODO: Mapear dom√≠nio para SQL
        pass
    
    def buscar_por_numero(self, numero: str) -> Optional[Conta]:
        # TODO: Buscar no banco e reconstruir agregado
        pass

# Adaptadores de Notifica√ß√£o
class AdaptadorNotificacaoEmail:
    """Adapter: Notifica√ß√µes por email"""
    
    def enviar_notificacao(self, destinatario: str, mensagem: str, canal: str) -> bool:
        if canal != "email":
            return False
        
        print(f"üìß Email para {destinatario}: {mensagem}")
        # TODO: Integra√ß√£o real com provedor de email
        return True

class AdaptadorNotificacaoSMS:
    """Adapter: Notifica√ß√µes por SMS"""
    
    def enviar_notificacao(self, destinatario: str, mensagem: str, canal: str) -> bool:
        if canal != "sms":
            return False
        
        print(f"üì± SMS para {destinatario}: {mensagem}")
        # TODO: Integra√ß√£o real com provedor de SMS
        return True

# Composite para m√∫ltiplos canais
class AdaptadorNotificacaoMulticanal:
    """Adapter: Composite para m√∫ltiplos canais"""
    
    def __init__(self):
        self._adaptadores = []
    
    def adicionar_adaptador(self, adaptador: ServicoNotificacao) -> None:
        self._adaptadores.append(adaptador)
    
    def enviar_notificacao(self, destinatario: str, mensagem: str, canal: str) -> bool:
        sucesso = False
        for adaptador in self._adaptadores:
            if adaptador.enviar_notificacao(destinatario, mensagem, canal):
                sucesso = True
        return sucesso

# Unit of Work
class UnidadeTrabalhoMemoria:
    """Unit of Work para reposit√≥rios em mem√≥ria"""
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            self.rollback()
    
    def commit(self) -> None:
        # Para mem√≥ria, commit √© no-op
        pass
    
    def rollback(self) -> None:
        # Para mem√≥ria, rollback seria complexo
        pass

# =============================================================================
# CONFIGURA√á√ÉO E COMPOSI√á√ÉO (Dependency Injection)
# =============================================================================

class ContainerDependencias:
    """Container de inje√ß√£o de depend√™ncias"""
    
    def __init__(self):
        self._servicos = {}
    
    def registrar(self, interface, implementacao):
        self._servicos[interface] = implementacao
    
    def resolver(self, interface):
        return self._servicos.get(interface)
    
    def configurar_para_desenvolvimento(self):
        """Configura√ß√£o para ambiente de desenvolvimento"""
        # Reposit√≥rios em mem√≥ria
        self.registrar(RepositorioConta, RepositorioContaMemoria())
        self.registrar(RepositorioTransacao, None)  # TODO
        
        # Servi√ßos
        self.registrar(ServicoNotificacao, AdaptadorNotificacaoEmail())
        self.registrar(UnidadeTrabalho, UnidadeTrabalhoMemoria())
        
        # Handlers
        self.registrar(ManipuladorComandoCriarConta, 
                      ManipuladorComandoCriarConta(
                          self.resolver(RepositorioConta),
                          self.resolver(ServicoNotificacao),
                          self.resolver(UnidadeTrabalho)
                      ))

# =============================================================================
# INTERFACE DE USU√ÅRIO (Adapter para API/CLI)
# =============================================================================

class FachadeSistemaBancario:
    """Facade para simplificar uso do sistema"""
    
    def __init__(self, container: ContainerDependencias):
        self._container = container
    
    def criar_conta(self, cpf: str, tipo: str, saldo_inicial: float = 0.0) -> str:
        """API simplificada para cria√ß√£o de conta"""
        handler = self._container.resolver(ManipuladorComandoCriarConta)
        comando = ComandoCriarConta(
            cpf=cpf,
            tipo=TipoConta(tipo),
            saldo_inicial=Decimal(str(saldo_inicial))
        )
        return handler.handle(comando)
    
    def realizar_transferencia(self, origem: str, destino: str, valor: float) -> str:
        """API simplificada para transfer√™ncia"""
        # TODO: Implementar usando handler de transfer√™ncia
        pass
    
    def consultar_saldo(self, numero_conta: str) -> dict:
        """Consulta saldo da conta"""
        repo = self._container.resolver(RepositorioConta)
        conta = repo.buscar_por_numero(numero_conta)
        
        if not conta:
            raise ValueError("Conta n√£o encontrada")
        
        return {
            "numero": conta.numero,
            "saldo": float(conta.saldo.valor),
            "moeda": conta.saldo.moeda,
            "tipo": conta.tipo.value,
            "ativa": conta.ativa
        }
```

### üß™ Cen√°rios de Teste Avan√ßados

```python
# TODO: Implementar su√≠te completa de testes
import pytest
from decimal import Decimal

class TestSistemaBancarioCompleto:
    """Testes de integra√ß√£o do sistema completo"""
    
    def setup_method(self):
        """Configura√ß√£o para cada teste"""
        self.container = ContainerDependencias()
        self.container.configurar_para_desenvolvimento()
        self.facade = FachadeSistemaBancario(self.container)
    
    def test_fluxo_completo_criacao_conta_e_transferencia(self):
        """Teste do fluxo principal do sistema"""
        # Criar contas
        conta1 = self.facade.criar_conta("12345678901", "corrente", 1000.0)
        conta2 = self.facade.criar_conta("10987654321", "poupanca", 0.0)
        
        # Consultar saldos iniciais
        saldo1 = self.facade.consultar_saldo(conta1)
        saldo2 = self.facade.consultar_saldo(conta2)
        
        assert saldo1["saldo"] == 1000.0
        assert saldo2["saldo"] == 0.0
        
        # Realizar transfer√™ncia
        # TODO: Implementar quando handler estiver pronto
        
    def test_especificacoes_negocio_complexas(self):
        """Testa Specification Pattern com regras complexas"""
        # TODO: Implementar testes de especifica√ß√µes
        pass
    
    def test_eventos_dominio_publicados(self):
        """Testa se eventos s√£o publicados corretamente"""
        # TODO: Implementar verifica√ß√£o de eventos
        pass
    
    def test_transacao_com_rollback(self):
        """Testa rollback em caso de falha"""
        # TODO: Simular falha e verificar rollback
        pass
```

### üìù Exemplo de Uso do Sistema

```python
def exemplo_uso_sistema():
    """Demonstra√ß√£o do sistema banc√°rio completo"""
    
    # Configurar container de depend√™ncias
    container = ContainerDependencias()
    container.configurar_para_desenvolvimento()
    
    # Inicializar facade
    sistema = FachadeSistemaBancario(container)
    
    try:
        # Criar contas
        print("üè¶ Criando contas...")
        conta_joao = sistema.criar_conta("12345678901", "corrente", 5000.0)
        conta_maria = sistema.criar_conta("10987654321", "poupanca", 1000.0)
        
        print(f"‚úÖ Conta do Jo√£o: {conta_joao}")
        print(f"‚úÖ Conta da Maria: {conta_maria}")
        
        # Consultar saldos
        print("\nüí∞ Consultando saldos...")
        saldo_joao = sistema.consultar_saldo(conta_joao)
        saldo_maria = sistema.consultar_saldo(conta_maria)
        
        print(f"Jo√£o: R$ {saldo_joao['saldo']}")
        print(f"Maria: R$ {saldo_maria['saldo']}")
        
        # Realizar transfer√™ncia
        print("\nüí∏ Realizando transfer√™ncia...")
        # sistema.realizar_transferencia(conta_joao, conta_maria, 500.0)
        
        print("‚úÖ Sistema banc√°rio funcionando!")
        
    except Exception as e:
        print(f"‚ùå Erro: {e}")

if __name__ == "__main__":
    exemplo_uso_sistema()
```

---

## Exerc√≠cio 3.2: Sistema de Monitoramento Distribu√≠do (2-3 horas)

### üìã Descri√ß√£o
Implemente um sistema de monitoramento distribu√≠do aplicando **Event Sourcing**, **CQRS**, **Publish-Subscribe Pattern** e **Microservices Communication Patterns**.

### üéØ Cen√°rio
Sistema que monitora m√∫ltiplos servi√ßos em tempo real:
- Coleta m√©tricas de CPU, mem√≥ria, rede
- Detecta anomalias usando machine learning
- Envia alertas autom√°ticos
- Mant√©m hist√≥rico completo para an√°lise
- Dashboard em tempo real

### üìã Requisitos T√©cnicos Avan√ßados

#### **Event Sourcing:**
- Todos os eventos s√£o persistidos
- Estado reconstru√≠do a partir de eventos
- Snapshots para performance
- Replay de eventos para debugging

#### **CQRS Completo:**
- Commands para escrita
- Queries para leitura
- Proje√ß√µes espec√≠ficas por use case
- Event handlers ass√≠ncronos

#### **Patterns de Comunica√ß√£o:**
- Message Queue para eventos
- Circuit Breaker para resili√™ncia
- Retry Pattern com backoff
- Saga Pattern para transa√ß√µes distribu√≠das

### üíª Estrutura Avan√ßada

```python
# TODO: Implementar sistema completo
# Base fornecida - expandir conforme necess√°rio

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, AsyncIterator
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from enum import Enum
import asyncio
import json
import uuid

class TipoEvento(Enum):
    METRICA_COLETADA = "metrica_coletada"
    ANOMALIA_DETECTADA = "anomalia_detectada"
    ALERTA_ENVIADO = "alerta_enviado"
    SERVICO_INDISPONIVEL = "servico_indisponivel"

@dataclass
class EventoSistema:
    """Event Sourcing - Evento base"""
    id: str
    tipo: TipoEvento
    agregado_id: str
    dados: Dict[str, Any]
    timestamp: datetime
    versao: int
    
    def to_dict(self) -> dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict) -> 'EventoSistema':
        return cls(**data)

# TODO: Implementar Event Store
class EventStore(ABC):
    """Interface para persist√™ncia de eventos"""
    
    @abstractmethod
    async def salvar_evento(self, evento: EventoSistema) -> None:
        pass
    
    @abstractmethod
    async def obter_eventos(self, agregado_id: str, 
                           desde_versao: int = 0) -> AsyncIterator[EventoSistema]:
        pass
    
    @abstractmethod
    async def obter_eventos_por_tipo(self, tipo: TipoEvento,
                                   desde: datetime) -> AsyncIterator[EventoSistema]:
        pass

# TODO: Implementar Message Bus
class MessageBus(ABC):
    """Interface para comunica√ß√£o ass√≠ncrona"""
    
    @abstractmethod
    async def publicar(self, evento: EventoSistema) -> None:
        pass
    
    @abstractmethod
    async def subscrever(self, tipo: TipoEvento, handler) -> None:
        pass

# TODO: Implementar Agregados com Event Sourcing
class ServicoMonitorado:
    """Agregado que reconstr√≥i estado a partir de eventos"""
    
    def __init__(self, id: str):
        self.id = id
        self.nome: Optional[str] = None
        self.ativo: bool = True
        self.ultima_metrica: Optional[datetime] = None
        self.alertas_ativos: List[str] = []
        self._versao = 0
        self._eventos_nao_salvos: List[EventoSistema] = []
    
    @classmethod
    async def reconstruir_de_eventos(cls, id: str, 
                                   event_store: EventStore) -> 'ServicoMonitorado':
        """Reconstr√≥i agregado a partir do Event Store"""
        servico = cls(id)
        
        async for evento in event_store.obter_eventos(id):
            servico._aplicar_evento(evento)
        
        return servico
    
    def _aplicar_evento(self, evento: EventoSistema) -> None:
        """Aplica evento ao estado interno"""
        self._versao = evento.versao
        
        if evento.tipo == TipoEvento.METRICA_COLETADA:
            self.ultima_metrica = evento.timestamp
            # TODO: Processar m√©tricas
        
        elif evento.tipo == TipoEvento.ANOMALIA_DETECTADA:
            # TODO: Processar anomalia
            pass
    
    def coletar_metrica(self, cpu: float, memoria: float, rede: float) -> None:
        """Command: Coletar nova m√©trica"""
        evento = EventoSistema(
            id=str(uuid.uuid4()),
            tipo=TipoEvento.METRICA_COLETADA,
            agregado_id=self.id,
            dados={"cpu": cpu, "memoria": memoria, "rede": rede},
            timestamp=datetime.now(),
            versao=self._versao + 1
        )
        
        self._aplicar_evento(evento)
        self._eventos_nao_salvos.append(evento)

# TODO: Implementar handlers CQRS
class HandlerComandoColetarMetrica:
    """Command Handler para coleta de m√©tricas"""
    
    def __init__(self, event_store: EventStore, message_bus: MessageBus):
        self._event_store = event_store
        self._message_bus = message_bus
    
    async def handle(self, comando) -> None:
        """Processa comando de coleta"""
        # TODO: Implementar l√≥gica completa
        pass

# TODO: Implementar proje√ß√µes para queries
class ProjecaoMetricasTempoReal:
    """Proje√ß√£o otimizada para dashboard em tempo real"""
    
    def __init__(self):
        self._metricas_atuais: Dict[str, Dict] = {}
    
    async def processar_evento(self, evento: EventoSistema) -> None:
        """Atualiza proje√ß√£o baseada em evento"""
        if evento.tipo == TipoEvento.METRICA_COLETADA:
            self._metricas_atuais[evento.agregado_id] = evento.dados

class ProjecaoHistoricoCompleto:
    """Proje√ß√£o para an√°lise hist√≥rica"""
    # TODO: Implementar
    pass

# TODO: Implementar Circuit Breaker
class CircuitBreaker:
    """Pattern para resili√™ncia em chamadas externas"""
    
    def __init__(self, failure_threshold: int = 5, 
                 recovery_timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time: Optional[datetime] = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    
    async def call(self, func, *args, **kwargs):
        """Executa fun√ß√£o com circuit breaker"""
        # TODO: Implementar l√≥gica completa
        pass
```

### üß™ Casos de Teste para Sistema Distribu√≠do

```python
class TestSistemaMonitoramento:
    
    @pytest.mark.asyncio
    async def test_event_sourcing_reconstroi_estado(self):
        """Testa reconstru√ß√£o de agregado via eventos"""
        # TODO: Implementar
        pass
    
    @pytest.mark.asyncio
    async def test_cqrs_separacao_comando_query(self):
        """Testa separa√ß√£o entre comandos e queries"""
        # TODO: Implementar
        pass
    
    @pytest.mark.asyncio
    async def test_circuit_breaker_resiliencia(self):
        """Testa circuit breaker em falhas"""
        # TODO: Implementar
        pass
```

---

## üìä Resumo do N√≠vel 3

Ao completar estes exerc√≠cios avan√ßados, voc√™ ter√° dominado:

‚úÖ **Arquitetura Hexagonal completa**
‚úÖ **Domain-Driven Design (DDD)**
‚úÖ **Event Sourcing & CQRS**
‚úÖ **Microservices Patterns**
‚úÖ **Specification Pattern**
‚úÖ **Unit of Work & Repository**
‚úÖ **Command Pattern avan√ßado**
‚úÖ **Circuit Breaker & Resilience**

### üéØ Compet√™ncias Desenvolvidas

- **Arquitetura Empresarial**: Design de sistemas complexos
- **Patterns Avan√ßados**: Aplica√ß√£o de patterns em cen√°rios reais
- **Resili√™ncia**: Sistemas tolerantes a falhas
- **Performance**: Otimiza√ß√£o e escalabilidade
- **Manutenibilidade**: C√≥digo limpo e test√°vel

---

**‚è±Ô∏è Tempo estimado total: 5-7 horas**
**üéñÔ∏è N√≠vel de dificuldade: Avan√ßado**
**üéì N√≠vel: Arquiteto de Software**
**üìö Conceitos: Arquitetura empresarial, DDD, Event Sourcing, Microservices**
